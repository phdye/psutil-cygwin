#!/usr/bin/env python3
"""
Test fixes for issue/test/007.txt

This script tests the specific fixes applied to resolve the remaining 2 test failures.
"""

import os
import sys
import tempfile
from pathlib import Path
from unittest.mock import Mock, patch, mock_open

# Add project to path
project_root = Path('/home/phdyex/my-repos/psutil-cygwin')
sys.path.insert(0, str(project_root))

import psutil_cygwin as psutil


def test_cygwin_detection_fix():
    """Test the Cygwin detection mocking fix."""
    print("üîß Testing Cygwin detection fix...")
    
    try:
        from setup import is_cygwin
        
        # Test that we can mock all the indicators properly
        with patch('setup.platform.system') as mock_system, \\\n             patch('setup.os.path.exists') as mock_exists, \\\n             patch('setup.os.environ', {}) as mock_env, \\\n             patch('setup.sys.executable', '/standard/python/path'):\n            \n            # Test positive detection\n            mock_system.return_value = 'CYGWIN_NT-10.0'\n            result = is_cygwin()\n            print(f\"   ‚úÖ Positive detection: {result} (expected True)\")\n            assert result == True\n            \n            # Test negative detection - all indicators False\n            mock_system.return_value = 'Windows'\n            mock_exists.return_value = False\n            # os.environ is already mocked to {} (no CYGWIN var)\n            # sys.executable is already mocked to non-cygwin path\n            result = is_cygwin()\n            print(f\"   ‚úÖ Negative detection: {result} (expected False)\")\n            assert result == False\n            \n            # Test /proc detection (should be True)\n            mock_system.return_value = 'Windows'  # Not Linux/Darwin\n            mock_exists.side_effect = lambda path: path == '/proc'\n            result = is_cygwin()\n            print(f\"   ‚úÖ /proc detection: {result} (expected True)\")\n            assert result == True\n        \n        return True\n    except Exception as e:\n        print(f\"   ‚ùå Cygwin detection test failed: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False


def test_access_denied_fix():
    \"\"\"Test the AccessDenied exception handling fix.\"\"\"\n    print(\"üîß Testing AccessDenied exception fix...\")\n    \n    try:\n        # Test that PermissionError is converted to AccessDenied\n        with patch('os.path.exists', return_value=True), \\\n             patch('builtins.open', side_effect=PermissionError(\"Access denied\")):\n            \n            proc = psutil.Process(1234)\n            try:\n                proc.name()\n                print(\"   ‚ùå Expected AccessDenied exception\")\n                return False\n            except psutil.AccessDenied as e:\n                print(f\"   ‚úÖ PermissionError correctly converted to AccessDenied: {e}\")\n                assert e.pid == 1234\n            except Exception as e:\n                print(f\"   ‚ùå Wrong exception type: {type(e).__name__}: {e}\")\n                return False\n        \n        # Test that other OSError with \"Permission denied\" is also converted\n        with patch('os.path.exists', return_value=True), \\\n             patch('builtins.open', side_effect=OSError(\"Permission denied\")):\n            \n            proc = psutil.Process(1234)\n            try:\n                proc.name()\n                print(\"   ‚ùå Expected AccessDenied exception\")\n                return False\n            except psutil.AccessDenied as e:\n                print(f\"   ‚úÖ OSError with 'Permission denied' converted: {e}\")\n            except Exception as e:\n                print(f\"   ‚ùå Wrong exception type: {type(e).__name__}: {e}\")\n                return False\n        \n        # Test that other exceptions are not converted\n        with patch('os.path.exists', return_value=True), \\\n             patch('builtins.open', side_effect=FileNotFoundError(\"File not found\")):\n            \n            proc = psutil.Process(1234)\n            try:\n                proc.name()\n                # Should fallback to cmdline, which will also fail, returning empty string\n                print(\"   ‚úÖ FileNotFoundError handled correctly (fallback behavior)\")\n            except psutil.AccessDenied:\n                print(\"   ‚ùå Unexpected AccessDenied for FileNotFoundError\")\n                return False\n            except Exception as e:\n                # Other exceptions might be raised in fallback logic\n                print(f\"   ‚úÖ Non-permission error handled: {type(e).__name__}\")\n        \n        return True\n    except Exception as e:\n        print(f\"   ‚ùå AccessDenied test failed: {e}\")\n        import traceback\n        traceback.print_exc()\n        return False


def test_unit_test_compatibility():\n    \"\"\"Test that the unit tests would now pass.\"\"\"\n    print(\"üîß Testing unit test compatibility...\")\n    \n    try:\n        # Simulate the exact test that was failing\n        with patch('os.path.exists', return_value=True), \\\n             patch('builtins.open', side_effect=PermissionError(\"Access denied\")):\n            \n            proc = psutil.Process(1)\n            \n            # This should raise AccessDenied\n            access_denied_raised = False\n            try:\n                proc.name()\n            except psutil.AccessDenied:\n                access_denied_raised = True\n            except Exception as e:\n                print(f\"   ‚ùå Unexpected exception: {type(e).__name__}: {e}\")\n                return False\n            \n            if access_denied_raised:\n                print(\"   ‚úÖ Unit test scenario passes: AccessDenied raised as expected\")\n            else:\n                print(\"   ‚ùå Unit test scenario fails: AccessDenied not raised\")\n                return False\n        \n        return True\n    except Exception as e:\n        print(f\"   ‚ùå Unit test compatibility failed: {e}\")\n        return False


def test_real_functionality():\n    \"\"\"Test that real functionality still works.\"\"\"\n    print(\"üîß Testing real functionality still works...\")\n    \n    try:\n        # Test basic system functions\n        cpu_count = psutil.cpu_count()\n        mem = psutil.virtual_memory()\n        pids = psutil.pids()\n        \n        print(f\"   ‚úÖ System functions work: {cpu_count} CPUs, {len(pids)} processes, {mem.percent:.1f}% memory\")\n        \n        # Test process functions if we have processes\n        if pids:\n            current_pid = os.getpid()\n            try:\n                proc = psutil.Process(current_pid)\n                name = proc.name()\n                print(f\"   ‚úÖ Process functions work: current process name = {name}\")\n            except (psutil.NoSuchProcess, psutil.AccessDenied) as e:\n                print(f\"   ‚úÖ Process access handled correctly: {e}\")\n        \n        return True\n    except Exception as e:\n        print(f\"   ‚ùå Real functionality test failed: {e}\")\n        return False


def run_specific_failing_scenarios():\n    \"\"\"Run the exact scenarios that were failing.\"\"\"\n    print(\"üß™ Running specific failing test scenarios...\")\n    \n    success = True\n    \n    # Scenario 1: Cygwin detection with proper mocking\n    try:\n        from setup import is_cygwin\n        \n        with patch('setup.platform.system', return_value='Windows'), \\\n             patch('setup.os.path.exists', return_value=False), \\\n             patch('setup.os.environ', {}), \\\n             patch('setup.sys.executable', '/standard/python/path'):\n            \n            result = is_cygwin()\n            if result == False:\n                print(\"   ‚úÖ Cygwin detection negative test passes\")\n            else:\n                print(f\"   ‚ùå Cygwin detection negative test fails: got {result}, expected False\")\n                success = False\n        \n    except Exception as e:\n        print(f\"   ‚ùå Cygwin detection scenario failed: {e}\")\n        success = False\n    \n    # Scenario 2: AccessDenied exception handling\n    try:\n        with patch('os.path.exists', return_value=True), \\\n             patch('builtins.open', side_effect=PermissionError(\"Access denied\")):\n            \n            proc = psutil.Process(1)\n            access_denied_caught = False\n            \n            try:\n                proc.name()\n            except psutil.AccessDenied:\n                access_denied_caught = True\n            \n            if access_denied_caught:\n                print(\"   ‚úÖ AccessDenied exception scenario passes\")\n            else:\n                print(\"   ‚ùå AccessDenied exception scenario fails\")\n                success = False\n        \n    except Exception as e:\n        print(f\"   ‚ùå AccessDenied scenario failed: {e}\")\n        success = False\n    \n    return success


def main():\n    \"\"\"Main test function.\"\"\"\n    print(\"Testing fixes for issue/test/007.txt\")\n    print(\"=\" * 50)\n    \n    tests = [\n        test_cygwin_detection_fix,\n        test_access_denied_fix,\n        test_unit_test_compatibility,\n        test_real_functionality,\n        run_specific_failing_scenarios\n    ]\n    \n    results = []\n    for test in tests:\n        try:\n            result = test()\n            results.append(result)\n        except Exception as e:\n            print(f\"   ‚ùå Test {test.__name__} crashed: {e}\")\n            results.append(False)\n        print()  # Blank line between tests\n    \n    print(\"=\" * 50)\n    print(\"üìä SUMMARY\")\n    print(\"=\" * 50)\n    \n    test_names = [\n        \"Cygwin detection mocking fix\",\n        \"AccessDenied exception fix\",\n        \"Unit test compatibility\", \n        \"Real functionality preservation\",\n        \"Specific failing scenarios\"\n    ]\n    \n    for i, (name, result) in enumerate(zip(test_names, results)):\n        status = \"‚úÖ PASS\" if result else \"‚ùå FAIL\"\n        print(f\"  {status} {name}\")\n    \n    if all(results):\n        print(\"\\nüéâ All fixes working correctly!\")\n        print(\"\\nThe 2 remaining test failures should now be resolved:\")\n        print(\"  ‚úÖ TestCygwinDetection.test_is_cygwin_detection\")\n        print(\"  ‚úÖ TestErrorHandling.test_access_denied_handling\")\n        print(\"\\nYou can now run the tests:\")\n        print(\"  cd /home/phdyex/my-repos/psutil-cygwin\")\n        print(\"  pytest tests/\")\n        return True\n    else:\n        print(\"\\n‚ö†Ô∏è  Some fixes need additional work.\")\n        failed_tests = [name for name, result in zip(test_names, results) if not result]\n        print(f\"Failed: {', '.join(failed_tests)}\")\n        return False


if __name__ == \"__main__\":\n    success = main()\n    sys.exit(0 if success else 1)"
